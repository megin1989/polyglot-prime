<channel version="4.5.3">
  <id>25dd1794-5435-4282-a189-4a2df9aed0a2</id>
  <nextMetaDataId>3</nextMetaDataId>
  <name>HL7V2 Bundle</name>
  <description>Version: 0.3.1</description>
  <revision>117</revision>
  <sourceConnector version="4.5.3">
    <metaDataId>0</metaDataId>
    <name>sourceConnector</name>
    <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="4.5.3">
      <pluginProperties>
        <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="4.5.3">
  <authType>NONE</authType>
        </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
        <com.mirth.connect.plugins.ssl.SSLSettingsProperties version="4.5.3">
  <sslEnabled>false</sslEnabled>
          <mutualTlsEnabled>false</mutualTlsEnabled>
          <verifyHostname>false</verifyHostname>
          <keystorePath/>
          <keystorePassword/>
          <certAlias/>
          <certPassword/>
          <truststorePath/>
          <truststorePassword/>
          <tls13>true</tls13>
          <tls12>true</tls12>
          <tls11>true</tls11>
          <keystoreType/>
          <truststoreType/>
          <keystoreSettingFromSystem>false</keystoreSettingFromSystem>
          <keystoreUid/>
          <myCertificateAlias/>
          <truststoreSettingFromSystem>false</truststoreSettingFromSystem>
          <truststoreUid/>
        </com.mirth.connect.plugins.ssl.SSLSettingsProperties>
      </pluginProperties>
      <listenerConnectorProperties version="4.5.3">
        <host>0.0.0.0</host>
        <port>9006</port>
      </listenerConnectorProperties>
      <sourceConnectorProperties version="4.5.3">
        <responseVariable>finalResponse</responseVariable>
        <respondAfterProcessing>true</respondAfterProcessing>
        <processBatch>false</processBatch>
        <firstResponse>false</firstResponse>
        <processingThreads>1</processingThreads>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
        <queueBufferSize>1000</queueBufferSize>
      </sourceConnectorProperties>
      <xmlBody>false</xmlBody>
      <parseMultipart>true</parseMultipart>
      <includeMetadata>false</includeMetadata>
      <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</binaryMimeTypes>
      <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
      <responseContentType>text/json</responseContentType>
      <responseDataTypeBinary>false</responseDataTypeBinary>
      <responseStatusCode>${status}</responseStatusCode>
      <responseHeaders class="linked-hash-map">
        <entry>
          <string>Access-Control-Allow-Origin</string>
          <list>
            <string>https://hub.dev.techbd.org</string>
          </list>
        </entry>
        <entry>
          <string>Access-Control-Allow-Methods</string>
          <list>
            <string>GET, POST, OPTIONS</string>
          </list>
        </entry>
        <entry>
          <string>Access-Control-Allow-Headers</string>
          <list>
            <string>Content-Type, Authorization, X-TechBD-Base-FHIR-URL, X-TechBD-Tenant-ID, User-Agent, X-TechBD-REMOTE-IP, X-TechBD-Override-Request-URI, X-Correlation-ID, accept, X-TechBD-DataLake-API-URL, DataLake-API-Content-Type, X-TechBD-HealthCheck, X-TechBD-Validation-Severity-Level, X-TechBD-CIN, X-TechBD-Facility-ID, X-TechBD-Encounter-Type, X-TechBD-OrgNPI, X-TechBD-OrgTIN</string>
          </list>
        </entry>
        <entry>
          <string>Access-Control-Allow-Credentials</string>
          <list>
            <string>true</string>
          </list>
        </entry>
      </responseHeaders>
      <responseHeadersVariable></responseHeadersVariable>
      <useResponseHeadersVariable>false</useResponseHeadersVariable>
      <charset>DEFAULT_ENCODING</charset>
      <contextPath>/</contextPath>
      <timeout>30000</timeout>
      <staticResources/>
    </properties>
    <transformer version="4.5.3">
      <elements/>
      <inboundTemplate encoding="base64"></inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundDataType>RAW</inboundDataType>
      <outboundDataType>RAW</outboundDataType>
      <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.3">
        <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.3">
          <splitType>JavaScript</splitType>
          <batchScript></batchScript>
        </batchProperties>
      </inboundProperties>
      <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.3">
        <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.3">
          <splitType>JavaScript</splitType>
          <batchScript></batchScript>
        </batchProperties>
      </outboundProperties>
    </transformer>
    <filter version="4.5.3">
      <elements>
        <com.mirth.connect.plugins.rulebuilder.RuleBuilderRule version="4.5.3">
          <name>Accept message if &quot;sourceMap.get(&apos;contextPath&apos;)&quot; equals &apos;/hl7v2/Bundle&apos; or &apos;/hl7v2/Bundle/&apos;</name>
          <sequenceNumber>0</sequenceNumber>
          <enabled>true</enabled>
          <field>sourceMap.get(&apos;contextPath&apos;)</field>
          <condition>EQUALS</condition>
          <values>
            <string>&apos;/hl7v2/Bundle&apos;</string>
            <string>&apos;/hl7v2/Bundle/&apos;</string>
          </values>
        </com.mirth.connect.plugins.rulebuilder.RuleBuilderRule>
        <com.mirth.connect.plugins.rulebuilder.RuleBuilderRule version="4.5.3">
          <name>Accept message if &quot;sourceMap.get(&apos;method&apos;)&quot; equals &apos;POST&apos;</name>
          <sequenceNumber>1</sequenceNumber>
          <enabled>true</enabled>
          <operator>AND</operator>
          <field>sourceMap.get(&apos;method&apos;)</field>
          <condition>EQUALS</condition>
          <values>
            <string>&apos;POST&apos;</string>
          </values>
        </com.mirth.connect.plugins.rulebuilder.RuleBuilderRule>
      </elements>
    </filter>
    <transportName>HTTP Listener</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <waitForPrevious>true</waitForPrevious>
  </sourceConnector>
  <destinationConnectors>
    <connector version="4.5.3">
      <metaDataId>1</metaDataId>
      <name>Destination 1</name>
      <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="4.5.3">
        <pluginProperties/>
        <destinationConnectorProperties version="4.5.3">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <channelId>none</channelId>
        <channelTemplate>${message.encodedData}</channelTemplate>
        <mapVariables/>
      </properties>
      <transformer version="4.5.3">
        <elements>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.5.3">
            <name>Common Js func.</name>
            <sequenceNumber>0</sequenceNumber>
            <enabled>true</enabled>
            <script>/**
* Replacer function to remove empty values
*/&#xd;function removeEmptyValues(key, value) {&#xd;  // Remove values that are empty strings, null, undefined, or empty objects/arrays&#xd;  if (value === &quot;&quot; || value === null || value === undefined || &#xd;      (typeof value === &quot;object&quot; &amp;&amp; Object.keys(value).length === 0) ||&#xd;      (Array.isArray(value) &amp;&amp; value.length === 0)) {&#xd;    return undefined; // Exclude the key from the result&#xd;  }&#xd;  return value; // Keep the value as is&#xd;}


/**
* Util function to generate json string wit hstatus and message
*/
function createJsonResponse(status, message) {
    return JSON.stringify({ status: status, message: message });
}

/**
* Util function to set error response.
*/
function setErrorResponse(statusCode, errorMessage) {
    responseMap.put(&apos;status&apos;, String(statusCode)); // Convert statusCode to string
    responseMap.put(&apos;message&apos;, errorMessage);
    responseMap.put(&apos;finalResponse&apos;, createJsonResponse(statusCode, errorMessage));
}

/*
* Util function to generate json error message
*/
function getJsonInvalidOperationOutcome(errorMsg, code) {
	return { &quot;OperationOutcome&quot;: {
                    &quot;validationResults&quot;: [
                        {
                            &quot;operationOutcome&quot;: {
                                &quot;resourceType&quot;: &quot;OperationOutcome&quot;,
                                &quot;issue&quot;: [
                                    {
                                        &quot;severity&quot;: &quot;error&quot;,
                                        &quot;code&quot;: code,
                                        &quot;details&quot;: {
                                            &quot;text&quot;: errorMsg
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            };
}

function sendDataLedgerSync(payload) {
    logger.info(&quot;sendDataLedgerSync: &quot; + payload);
    
    var apiUrl = java.lang.System.getenv(&quot;DATA_LEDGER_API_URL&quot;);
    var dataLedgerApiKey = java.lang.System.getenv(&quot;TECHBD_NYEC_DATALEDGER_API_KEY&quot;);

    logger.info(&quot;API URL: &quot; + apiUrl);

    if (apiUrl == null) {
        throw new Error(&quot;Environment variable DATA_LEDGER_API_URL is not set.&quot;);
    }
    if (dataLedgerApiKey == null) {
        throw new Error(&quot;Environment variable &apos;TECHBD_NYEC_DATALEDGER_API_KEY&apos; is not set.&quot;);
    }

    try {
        var HttpClients = org.apache.http.impl.client.HttpClients;
        var HttpPost = org.apache.http.client.methods.HttpPost;
        var StringEntity = org.apache.http.entity.StringEntity;
        var EntityUtils = org.apache.http.util.EntityUtils;

        var httpClient = HttpClients.createDefault();
        var httpPost = new HttpPost(apiUrl);

        httpPost.setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);
        httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;);
       
        if (dataLedgerApiKey != null) {
        	httpPost.setHeader(&quot;x-api-key&quot;, dataLedgerApiKey); // ✅ Add x-api-key header
        }

        var entity = new StringEntity(payload, &quot;UTF-8&quot;);
        httpPost.setEntity(entity);

        var response = httpClient.execute(httpPost);
        try {
            var statusCode = response.getStatusLine().getStatusCode();
            logger.info(&quot;sendDataLedgerSync response status: &quot; + statusCode);
            var responseBody = EntityUtils.toString(response.getEntity());

            if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300) {
                logger.info(&quot;Data Ledger API Response: &quot; + responseBody);
                return {
                    statusCode: statusCode,
                    body: responseBody
                };
            } else {
                logger.error(&quot;Data Ledger API Error. Status: &quot; + statusCode + &quot;, Response: &quot; + responseBody);
                throw new Error(&quot;Request failed with status &quot; + statusCode);
            }
        } finally {
            EntityUtils.consumeQuietly(response.getEntity());
        }
    } catch (error) {
        logger.error(&quot;Data Ledger API Request Failed: &quot; + error.message);
        throw error;
    }
}</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.5.3">
            <name>Validate HTTP Request and collect headers</name>
            <sequenceNumber>1</sequenceNumber>
            <enabled>true</enabled>
            <script>logger.info(&quot;HTTP request validation started.&quot;);

var requestedPath = sourceMap.get(&apos;contextPath&apos;);
logger.info(&quot;Request URL: &quot; + requestedPath);

if (requestedPath == &quot;/&quot;) {
	return;
}

// Initialize missing headers array
var missingHeaders = [];

// Helper to check and store missing header
function checkRequiredHeader(headerName, displayName, storeInMap, mapKey) {
    var value = $(&apos;headers&apos;).getHeader(headerName);
    logger.info(headerName + &quot;: &quot; + value);

    if (value == null || String(value).trim() === &quot;&quot;) {
        missingHeaders.push(&quot;Missing required header &quot; + displayName);
    } else if (storeInMap) {
        channelMap.put(mapKey || headerName, value);
    }

    return value;
}

///////////////////////////////////////////////////////////////////////////
// Access the required header values using getHeader method
// Mandatory: X-TechBD-Tenant-ID
checkRequiredHeader(&apos;X-TechBD-Tenant-ID&apos;, &apos;X-TechBD-Tenant-ID&apos;, true, &apos;tenantId&apos;);

// Retrieve the Content-Type header
var contentType = $(&apos;headers&apos;).getHeader(&apos;Content-Type&apos;);
// Check if the Content-Type is &apos;multipart/form-data&apos; and contains a boundary
if (!contentType || !contentType.startsWith(&apos;multipart/form-data&apos;) /*|| !contentType.includes(&apos;boundary=&apos;)*/) {
    missingHeaders.push(&quot;Content-Type must be &apos;multipart/form-data&apos; with boundary details&quot;);
}

// Get User-Agent header to set at HTTP Writer not to show &apos;Mirth connect&apos; as Agent at the application side.
var userAgent = $(&apos;headers&apos;).getHeader(&apos;User-Agent&apos;);
channelMap.put(&apos;userAgent&apos;, userAgent);
logger.info(&quot;User-Agent: &quot; + userAgent);

var OrganizationName = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Organization-Name&apos;);
channelMap.put(&apos;OrganizationName&apos;, OrganizationName);
logger.info(&quot;OrganizationName: &quot; + OrganizationName);

channelMap.put(&apos;uri&apos;, sourceMap.get(&apos;uri&apos;));
channelMap.put(&apos;contextPath&apos;, sourceMap.get(&apos;contextPath&apos;));

//** Get CIN, NPI and TIN from headers for CCDA FHIR Bundle - Required for FHIR Bundle conversion only**//
if (requestedPath == &quot;/hl7v2/Bundle/&quot; || requestedPath == &quot;/hl7v2/Bundle&quot;) {
	//1.CIN
	checkRequiredHeader(&apos;X-TechBD-CIN&apos;, &apos;X-TechBD-CIN&apos;, true, &apos;patientCIN&apos;);
	
	//2.NPI
	var organizationNPI = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-OrgNPI&apos;);
	logger.info(&quot;X-TechBD-OrgNPI: &quot; + organizationNPI);
	
	//3.TIN
	var organizationTIN = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-OrgTIN&apos;);
	logger.info(&quot;X-TechBD-OrgTIN: &quot; + organizationTIN);
	
	// Check if both are missing — only then it&apos;s an error
	if ((organizationNPI == null || String(organizationNPI).trim() === &quot;&quot;) &amp;&amp;
	    (organizationTIN == null || String(organizationTIN).trim() === &quot;&quot;)) {
	    missingHeaders.push(&quot;Missing required header X-TechBD-OrgNPI and X-TechBD-OrgTIN. One is mandatory.&quot;);
	} else {
	    if (organizationNPI &amp;&amp; String(organizationNPI).trim() !== &quot;&quot;) {
	        channelMap.put(&apos;organizationNPI&apos;, organizationNPI);
	    }
	    if (organizationTIN &amp;&amp; String(organizationTIN).trim() !== &quot;&quot;) {
	        channelMap.put(&apos;organizationTIN&apos;, organizationTIN);
	    }
	}
	
	//4. Facility Code
	checkRequiredHeader(&apos;X-TechBD-Facility-ID&apos;, &apos;X-TechBD-Facility-ID&apos;, true, &apos;facilityID&apos;);

	//5. Encounter Type
	checkRequiredHeader(&apos;X-TechBD-Encounter-Type&apos;, &apos;X-TechBD-Encounter-Type&apos;, true, &apos;encounterType&apos;);
}

// If any missing headers were found, throw a single error
if (missingHeaders.length &gt; 0) {
    var errorMessage = &quot;Bad Request: &quot; + missingHeaders.join(&quot;; &quot;);
    logger.error(errorMessage);
    setErrorResponse(400, errorMessage);
    throw errorMessage;
}



//////////////////////////////////////////////////////
// Read environment variables and set to global map //
//////////////////////////////////////////////////////

// Initialize missing environment variables array
var missingEnvVars = [];

// If any env vars are missing, throw a single error
if (missingEnvVars.length &gt; 0) {
    var errorMessage = &quot;Server Error: &quot; + missingEnvVars.join(&quot;; &quot;);
    logger.error(errorMessage);
    setErrorResponse(500, errorMessage); // Internal Server Error
    throw errorMessage;
}

logger.info(&quot;HTTP request validation ended.&quot;);</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.5.3">
            <name>step_validate_profile_urls_env_variables</name>
            <sequenceNumber>2</sequenceNumber>
            <enabled>true</enabled>
            <script>/**
* Util function to generate a hash string using sha-256 that can be used as the resource id in FHIR Bundle.
*/


/**
* Util function to get FHIR resource profile URLs and set as parameters to the transformer which converts the XML file to FHIR Bundle.
*/
function set_fhir_resource_profile_urls(transformer) {
	var baseFhirUrl = java.lang.System.getenv(&quot;BASE_FHIR_URL&quot;);   
	var bundleMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_BUNDLE&quot;); 
	var patientMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_PATIENT&quot;); 
	var encounterMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_ENCOUNTER&quot;); 
	var consentMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_CONSENT&quot;); 
	var organizationMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_ORGANIZATION&quot;); 
	var observationMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_OBSERVATION&quot;); 
	var observationSexualOrientationMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_SEXUAL_ORIENTATION&quot;); 
	var questionnaireMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_QUESTIONNAIRE&quot;); 
	var questionnaireResponseMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_QUESTIONNAIRE_RESPONSE&quot;); 
	var practitionerMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_PRACTITIONER&quot;);
	var procedureMetaProfileUrl = java.lang.System.getenv(&quot;PROFILE_URL_PROCEDURE&quot;);

	if(baseFhirUrl != null) {
		transformer.setParameter(&quot;baseFhirUrl&quot;, baseFhirUrl);
		channelMap.put(&apos;baseFhirUrl&apos;, baseFhirUrl);
		logger.info(&quot;baseFhirUrl: &quot; + baseFhirUrl);
	} else {
		var errorMessage = &apos;BASE_FHIR_URL variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
	
	if(bundleMetaProfileUrl != null) {
		transformer.setParameter(&quot;bundleMetaProfileUrl&quot;, bundleMetaProfileUrl);
		channelMap.put(&apos;bundleMetaProfileUrl&apos;, bundleMetaProfileUrl);
		logger.info(&quot;bundleMetaProfileUrl: &quot; + bundleMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_BUNDLE variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
	
	if(patientMetaProfileUrl != null) {
		transformer.setParameter(&quot;patientMetaProfileUrl&quot;, patientMetaProfileUrl);
		channelMap.put(&apos;patientMetaProfileUrl&apos;, patientMetaProfileUrl);
		logger.info(&quot;patientMetaProfileUrl: &quot; + patientMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_PATIENT variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
	
	if(encounterMetaProfileUrl != null) {
		transformer.setParameter(&quot;encounterMetaProfileUrl&quot;, encounterMetaProfileUrl);
		channelMap.put(&apos;encounterMetaProfileUrl&apos;, encounterMetaProfileUrl);
		logger.info(&quot;encounterMetaProfileUrl: &quot; + encounterMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_ENCOUNTER variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
	
	if(consentMetaProfileUrl != null) {
		transformer.setParameter(&quot;consentMetaProfileUrl&quot;, consentMetaProfileUrl);
		channelMap.put(&apos;consentMetaProfileUrl&apos;, consentMetaProfileUrl);
		logger.info(&quot;consentMetaProfileUrl: &quot; + consentMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_CONSENT variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
		
	if(organizationMetaProfileUrl != null) {
		transformer.setParameter(&quot;organizationMetaProfileUrl&quot;, organizationMetaProfileUrl);
		channelMap.put(&apos;organizationMetaProfileUrl&apos;, organizationMetaProfileUrl);
		logger.info(&quot;organizationMetaProfileUrl: &quot; + organizationMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_ORGANIZATION variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
			
	if(observationMetaProfileUrl != null) {
		transformer.setParameter(&quot;observationMetaProfileUrl&quot;, observationMetaProfileUrl);
		channelMap.put(&apos;observationMetaProfileUrl&apos;, observationMetaProfileUrl);
		logger.info(&quot;observationMetaProfileUrl: &quot; + observationMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_OBSERVATION variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
				
	if(observationSexualOrientationMetaProfileUrl != null) {
		transformer.setParameter(&quot;observationSexualOrientationMetaProfileUrl&quot;, observationSexualOrientationMetaProfileUrl);
		channelMap.put(&apos;observationSexualOrientationMetaProfileUrl&apos;, observationSexualOrientationMetaProfileUrl);
		logger.info(&quot;observationSexualOrientationMetaProfileUrl: &quot; + observationSexualOrientationMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_SEXUAL_ORIENTATION variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
					
	if(questionnaireMetaProfileUrl != null) {
		transformer.setParameter(&quot;questionnaireMetaProfileUrl&quot;, questionnaireMetaProfileUrl);
		channelMap.put(&apos;questionnaireMetaProfileUrl&apos;, questionnaireMetaProfileUrl);
		logger.info(&quot;questionnaireMetaProfileUrl: &quot; + questionnaireMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_QUESTIONNAIRE variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
						
	if(questionnaireResponseMetaProfileUrl != null) {
		transformer.setParameter(&quot;questionnaireResponseMetaProfileUrl&quot;, questionnaireResponseMetaProfileUrl);
		channelMap.put(&apos;questionnaireResponseMetaProfileUrl&apos;, questionnaireResponseMetaProfileUrl);
		logger.info(&quot;questionnaireResponseMetaProfileUrl: &quot; + questionnaireResponseMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_QUESTIONNAIRE_RESPONSE variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
							
	if(practitionerMetaProfileUrl != null) {
		transformer.setParameter(&quot;practitionerMetaProfileUrl&quot;, practitionerMetaProfileUrl);
		channelMap.put(&apos;practitionerMetaProfileUrl&apos;, practitionerMetaProfileUrl);
		logger.info(&quot;practitionerMetaProfileUrl: &quot; + practitionerMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_PRACTITIONER variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}

	if(procedureMetaProfileUrl != null) {
		transformer.setParameter(&quot;procedureMetaProfileUrl&quot;, procedureMetaProfileUrl);
		channelMap.put(&apos;procedureMetaProfileUrl&apos;, procedureMetaProfileUrl);
		logger.info(&quot;procedureMetaProfileUrl: &quot; + procedureMetaProfileUrl);
	} else {
		var errorMessage = &apos;PROFILE_URL_PROCEDURE variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}

	transformer.setParameter(&quot;patientCIN&quot;, channelMap.get(&apos;patientCIN&apos;)); // Pass the parameter to XSLT
	if (channelMap.get(&apos;organizationNPI&apos;)) {
		transformer.setParameter(&quot;organizationNPI&quot;, channelMap.get(&apos;organizationNPI&apos;)); // Pass the parameter to XSLT
	}		
	if (channelMap.get(&apos;organizationTIN&apos;)) {
		transformer.setParameter(&quot;organizationTIN&quot;, channelMap.get(&apos;organizationTIN&apos;)); // Pass the parameter to XSLT
	}
	if (channelMap.get(&apos;facilityID&apos;)) {
		transformer.setParameter(&quot;facilityID&quot;, channelMap.get(&apos;facilityID&apos;)); // Pass the parameter to XSLT
	}
	if (channelMap.get(&apos;encounterType&apos;)) {
		transformer.setParameter(&quot;encounterType&quot;, channelMap.get(&apos;encounterType&apos;)); // Pass the parameter to XSLT
	}
	if (channelMap.get(&apos;OrganizationName&apos;)) {
		transformer.setParameter(&quot;OrganizationName&quot;, channelMap.get(&apos;OrganizationName&apos;)); // Pass the parameter to XSLT
	}


	return transformer;
}

function getConsentResourceStatus(sourceXml) {&#xd;
 try {&#xd;
  var consentInfo = {};&#xd;
      consentInfo.code = &apos;Consent-Status&apos;;&#xd;
      consentInfo.status = &quot;TechBD-Generated&quot;;&#xd;
  var xmlDoc = new XML(sourceXml); // Convert XML string to XML object   &#xd;
  //default xml namespace = &quot;urn:hl7-org:v3&quot;; // Default namespace for HL7 documents&#xd;
  var consentCode = &quot;&quot;;&#xd;
  for each (var obx in xmlDoc..OBX) {&#xd;
      var obx32 = &quot;&quot;;&#xd;
      if (obx[&quot;OBX.3&quot;] != null &amp;&amp; obx[&quot;OBX.3&quot;][&quot;OBX.3.2&quot;] != null) {&#xd;
          obx32 = obx[&quot;OBX.3&quot;][&quot;OBX.3.2&quot;].toString();&#xd;
      }&#xd;
  &#xd;
      if (obx32 == &quot;AHC-HRSN Patient Consent&quot;) {&#xd;
          if (obx[&quot;OBX.5&quot;] != null &amp;&amp; obx[&quot;OBX.5&quot;][&quot;OBX.5.1&quot;] != null) {&#xd;
              consentCode = obx[&quot;OBX.5&quot;][&quot;OBX.5.1&quot;].toString();&#xd;
          }&#xd;
          break;&#xd;
      }&#xd;
  }&#xd;
  logger.info(&quot;Consent Code: &quot; + consentCode);&#xd;
  if (consentCode != undefined &amp;&amp; consentCode.length &gt; 0) {&#xd;
      logger.info(&quot;Consent Code: &quot; + consentCode);&#xd;
          consentInfo.status = &quot;provided&quot;;&#xd;
  }  &#xd;
  // Convert to JSON string (optional, for sending/logging)&#xd;
  var consentJsonString = JSON.stringify(consentInfo);&#xd;
  logger.info(&quot;Consent Info JSON: &quot; + consentJsonString);&#xd;
  channelMap.put(&apos;elaboration&apos;, consentJsonString);&#xd;
 } catch (e) {&#xd;
        var errorMsg;&#xd;
        if (e instanceof JavaException) {&#xd;
           errorMsg = &quot;Error parsing Consent Resource: &quot; + e.toString();&#xd;
        } else {&#xd;
           errorMsg = &quot;Unexpected error during getting Consent Resource: &quot; + e.message;&#xd;
        }&#xd;
        logger.error(errorMsg);&#xd;
 &#xd;
        // Failure: Return an OperationOutcome JSON response with validation errors&#xd;
        responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;)));&#xd;
 &#xd;
        throw new Error(errorMsg);&#xd;
     }&#xd;
}&#xd;
&#xd;
function getCategoryDisplay(code) {&#xd;
    switch (code) {&#xd;
        case &apos;71802-3&apos;:&#xd;
            return &apos;Housing Instability&apos;;&#xd;
        case &apos;96778-6&apos;:&#xd;
            return &apos;Inadequate Housing&apos;;&#xd;
        case &apos;96779-4&apos;:&#xd;
            return &apos;Utility Insecurity&apos;;&#xd;
        case &apos;88122-7&apos;:&#xd;
        case &apos;88123-5&apos;:&#xd;
            return &apos;Food Insecurity&apos;;&#xd;
        case &apos;93030-5&apos;:&#xd;
            return &apos;Transportation Insecurity&apos;;&#xd;
        case &apos;96780-2&apos;:&#xd;
            return &apos;Employment Status&apos;;&#xd;
        case &apos;96782-8&apos;:&#xd;
        case &apos;95618-5&apos;:&#xd;
        case &apos;95617-7&apos;:&#xd;
        case &apos;95616-9&apos;:&#xd;
        case &apos;95615-1&apos;:&#xd;
        case &apos;95614-4&apos;:&#xd;
            return &apos;SDOH Category Unspecified&apos;;&#xd;
        default:&#xd;
            return &apos;SDOH Category Unspecified&apos;;&#xd;
    }&#xd;
}&#xd;
&#xd;
function getCategoryCode(code) {&#xd;
    switch (code) {&#xd;
        case &apos;71802-3&apos;:&#xd;
            return &apos;housing-instability&apos;;&#xd;
        case &apos;96778-6&apos;:&#xd;
            return &apos;inadequate-housing&apos;;&#xd;
        case &apos;96779-4&apos;:&#xd;
            return &apos;utility-insecurity&apos;;&#xd;
        case &apos;88122-7&apos;:&#xd;
        case &apos;88123-5&apos;:&#xd;
            return &apos;food-insecurity&apos;;&#xd;
        case &apos;93030-5&apos;:&#xd;
            return &apos;transportation-insecurity&apos;;&#xd;
        case &apos;96780-2&apos;:&#xd;
            return &apos;employment-status&apos;;&#xd;
        case &apos;96782-8&apos;:&#xd;
        case &apos;95618-5&apos;:&#xd;
        case &apos;95617-7&apos;:&#xd;
        case &apos;95616-9&apos;:&#xd;
        case &apos;95615-1&apos;:&#xd;
        case &apos;95614-4&apos;:&#xd;
            return &apos;sdoh-category-unspecified&apos;;&#xd;
        default:&#xd;
            return null;&#xd;
    }&#xd;
}&#xd;
&#xd;
// Define Namespace Resolver&#xd;
function getObservationCategoryCodes(transformer, observations) {    &#xd;
    var xml = new XML(observations);  &#xd;
&#xd;
    var categorySystem = &quot;http://hl7.org/fhir/us/sdoh-clinicalcare/CodeSystem/SDOHCC-CodeSystemTemporaryCodes&quot;;&#xd;
&#xd;
 var categorySet = {};&#xd;
&#xd;
 var children = xml.children();&#xd;
    var currentOBR = null;&#xd;
&#xd;
    for each (var child in children) {&#xd;
     var nodeName = child.name().localName;&#xd;
 &#xd;
     if (nodeName === &apos;OBR&apos;) {&#xd;
         currentOBR = child;&#xd;
     } else if (nodeName === &apos;OBX&apos; &amp;&amp; currentOBR != null) {&#xd;
         var questionCode = &quot;&quot;;&#xd;
         var displayCode = &quot;&quot;;&#xd;
 &#xd;
         if (child[&quot;OBX.3&quot;] != null) {&#xd;
             if (child[&quot;OBX.3&quot;][&quot;OBX.3.1&quot;] != null) {&#xd;
                 questionCode = child[&quot;OBX.3&quot;][&quot;OBX.3.1&quot;].toString().trim();&#xd;
             }&#xd;
             if (child[&quot;OBX.3&quot;][&quot;OBX.3.2&quot;] != null) {&#xd;
                 displayCode = child[&quot;OBX.3&quot;][&quot;OBX.3.2&quot;].toString().trim();&#xd;
             }&#xd;
         }&#xd;
 &#xd;
         // Filter like in XSLT logic&#xd;
         if (questionCode === &apos;&apos; || displayCode === &apos;AHC-HRSN Patient Consent&apos;) {&#xd;
             continue;&#xd;
         }&#xd;
 &#xd;
         var categoryCode = getCategoryCode(questionCode);&#xd;
         var categoryDisplay = getCategoryDisplay(questionCode);&#xd;
 &#xd;
         if (categoryCode &amp;&amp; !(categoryCode in categorySet)) {&#xd;
             categorySet[categoryCode] = categoryDisplay;&#xd;
         }&#xd;
     }&#xd;
 }&#xd;
&#xd;
    // Build the category JSON array&#xd;
    var categoryJsonArray = [];&#xd;
    for (var code in categorySet) {&#xd;
        categoryJsonArray.push({&#xd;
            system: categorySystem,&#xd;
            code: code,&#xd;
            display: categorySet[code]&#xd;
        });&#xd;
    }&#xd;
&#xd;
     var categoryXml = JSON.stringify(categoryJsonArray);&#xd;
 &#xd;
 transformer.setParameter(&apos;categoryXml&apos;, categoryXml);&#xd;
 logger.info(&quot;categoryXml : &quot; + categoryXml);&#xd;
 return transformer;&#xd;
}&#xd;
&#xd;
function generateSHA256(inputString) {&#xd;
    //var md = MessageDigest.getInstance(&quot;SHA-256&quot;);&#xd;
    var md = Packages.java.security.MessageDigest.getInstance(&quot;SHA-256&quot;);&#xd;
    md.update(inputString.getBytes(&quot;UTF-8&quot;));   &#xd;
    var digest = md.digest();&#xd;
    return bytesToHex(digest);&#xd;
}&#xd;
&#xd;
function bytesToHex(byteArray) {&#xd;
    var hexString = new java.lang.StringBuilder();&#xd;
    for (var i = 0; i &lt; byteArray.length; i++) {&#xd;
        var hex = java.lang.Integer.toHexString(0xff &amp; byteArray[i]);&#xd;
        if (hex.length == 1) hexString.append(&apos;0&apos;);&#xd;
        hexString.append(hex);&#xd;
    }&#xd;
    return hexString.toString();&#xd;
}&#xd;
&#xd;
function getPatientMRN(sourceXml){&#xd;
 var xmlDoc = new XML(sourceXml);&#xd;
 var patientMRN = xmlDoc..PID[&quot;PID.3&quot;][&quot;PID.3.1&quot;].toString().trim();&#xd;
 channelMap.put(&apos;patientMRN&apos;, patientMRN);&#xd;
 logger.info(&quot;patientMRN: &quot; + patientMRN);&#xd;
 &#xd;
}&#xd;
&#xd;
function generateSHA256Id(sourceXml, resourceName, resourceIdName, transformer, additionalString) {&#xd;
    if (sourceXml != undefined) { &#xd;
     var xmlDoc = new XML(sourceXml);&#xd;
        // Get MRN and CIN from channelMap&#xd;
        var mrn = channelMap.get(&apos;Patient-MRN&apos;) || &quot;&quot;;&#xd;
        var cin = channelMap.get(&apos;patientCIN&apos;) || &quot;&quot;;&#xd;
        var combinedText = mrn + cin;&#xd;
&#xd;
        if (typeof additionalString !== &apos;undefined&apos; &amp;&amp; additionalString != null &amp;&amp; additionalString !== &apos;&apos;) {&#xd;
            combinedText += additionalString;&#xd;
            logger.info(&quot;Including additionalString in SHA-256: &quot; + additionalString);&#xd;
        }&#xd;
&#xd;
        var resourceText = resourceName + xmlDoc.toString().trim();&#xd;
        combinedText += resourceText;&#xd;
&#xd;
        // Generate SHA-256 hash&#xd;
        var sha256Hash = generateSHA256(new java.lang.String(combinedText));&#xd;
        transformer.setParameter(resourceIdName, sha256Hash);&#xd;
        logger.info(resourceIdName + &quot; : &quot; + sha256Hash);&#xd;
    } else {&#xd;
        logger.error(resourceName + &quot; not found in the XML.&quot;);&#xd;
    }&#xd;
&#xd;
    return transformer;&#xd;
}</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.5.3">
            <name>API endpoint processing</name>
            <sequenceNumber>3</sequenceNumber>
            <enabled>true</enabled>
            <script>var requestedPath = sourceMap.get(&apos;contextPath&apos;);logger.info(&quot;Request URL: &quot; + requestedPath);

if (requestedPath == &quot;/&quot;) {
	return;
}

// Retrieve logging functions&#xd;
var logInfo = globalMap.get(&quot;logInfo&quot;);&#xd;
var logError = globalMap.get(&quot;logError&quot;);&#xd;
var logDebug = globalMap.get(&quot;logDebug&quot;);&#xd;
var logError = globalMap.get(&quot;logError&quot;);

if (!globalMap.containsKey(&quot;hl7Service&quot;)) {&#xd;
    var hl7Service = SpringContextHolder.getBean(Packages.org.techbd.service.hl7.HL7Service);&#xd;
    globalMap.put(&quot;hl7Service&quot;, hl7Service);&#xd;
}&#xd;
var hl7Service = globalMap.get(&quot;hl7Service&quot;);&#xd;
&#xd;
logInfo(&quot;HL7Service bean loaded successfully.&quot;, channelMap);

if (requestedPath == &quot;/hl7v2/Bundle/&quot; || requestedPath == &quot;/hl7v2/Bundle&quot;) {
//////////////////////////////////////////////


    //*********** DATA LEDGER ***************
    var randomSuffix = Math.floor(Math.random() * 10000);
    channelMap.put(&apos;uri&apos;, sourceMap.get(&apos;uri&apos;));
   var currentTimestampBegin = new Date().toISOString().replace(/\.(\d{3})Z$/, function(match, millis) {
    // Add 3 more random digits to simulate microseconds
    var micros = millis + (Math.floor(Math.random() * 1000)).toString().padStart(3, &apos;0&apos;);
    return &apos;.&apos; + micros + &apos;Z&apos;;
  });


    var interactionId = java.util.UUID.randomUUID().toString();
    channelMap.put(&quot;interactionId&quot;,interactionId);
    logger.info(&quot;InteractionId: &quot; + interactionId);
    var payload = JSON.stringify({
        executedAt: currentTimestampBegin,
        actor: &quot;TechBD&quot;,
        action: &quot;received&quot;, 
        destination: &quot;TechBD&quot;,
        dataId: interactionId,
        payloadType: &quot;hrsnBundle&quot;
    });


	// Check if tracking is enabled
	var trackingEnabled = java.lang.System.getenv(&quot;DATA_LEDGER_TRACKING&quot;);
	if (trackingEnabled != null &amp;&amp; trackingEnabled.toLowerCase() == &quot;true&quot;) {
	    logger.info(&quot;data ledger api call -BEGIN received&quot;);
	    try {
	        sendDataLedgerSync(payload);
	    } catch (e) {
	        logger.error(&quot;Error occurred while sending data to Data Ledger: &quot; + e.message);
	    }
	    logger.info(&quot;data ledger api call -END received&quot;);
	} else {
	    logger.info(&quot;DATA_LEDGER_TRACKING is not true; skipping Data Ledger sync.&quot;);
	}
	//*********** DATA LEDGER ***************



	
	channelMap.put(&quot;endpoint&quot;, &quot;bundle&quot;);
	
	//var rawMessage =  connectorMessage.getTransformedData(); // msg contains the entire raw message


	
	
	var hl7Xml = channelMap.get(&quot;hl7Xml&quot;);
	
	if (hl7Xml) {
	    // Convert to JS string and remove leading whitespace/BOM
	    hl7Xml = String(hl7Xml).replace(/^\s+/, &apos;&apos;);
	    
	    var serializationProperties = SerializerFactory.getDefaultSerializationProperties(&apos;HL7V2&apos;);
	    var serializer = SerializerFactory.getSerializer(&apos;HL7V2&apos;, serializationProperties, null);
	    
	    var er7 = serializer.fromXML(hl7Xml); // This line expects clean, well-formed XML
	    
	    logger.info(&quot;Converted ER7:\n&quot; + er7);
	} else {
	    throw &quot;hl7Xml not found in globalMap.&quot;;
	}
	
	// You can assign it here if needed
	var rawMessage = hl7Xml;

	



	 // Success: Create a structured OperationOutcome JSON response&#xd;
        var successResponse = {&#xd;
            &quot;OperationOutcome&quot;: {&#xd;
                &quot;validationResults&quot;: [&#xd;
                    {&#xd;
                        &quot;operationOutcome&quot;: {&#xd;
                            &quot;resourceType&quot;: &quot;OperationOutcome&quot;,&#xd;
                            &quot;issue&quot;: [&#xd;
                                {&#xd;
                                    &quot;severity&quot;: &quot;information&quot;,&#xd;
                                    &quot;code&quot;: &quot;informational&quot;,&#xd;
                                    &quot;details&quot;: {&#xd;
                                        &quot;text&quot;: &quot;HL7 is valid according to the XSD.&quot;&#xd;
                                    }&#xd;
                                }&#xd;
                            ]&#xd;
                        }&#xd;
                    }&#xd;
                ]&#xd;
            }&#xd;
        };
	  // Step 1: Save the original HL7 payload
	  var hl7RawText = channelMap.get(&quot;hl7RawText&quot;);
	  var tenantIdentifier = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Tenant-ID&apos;);&#xd;
        var saveOriginalResult = hl7Service.saveOriginalHl7Payload(&#xd;
            interactionId,&#xd;
            tenantIdentifier,&#xd;
            requestedPath,&#xd;
            hl7RawText,&#xd;
            successResponse  &#xd;
        );&#xd;
        &#xd;
        if (saveOriginalResult) {&#xd;
            logInfo(&quot;***** Original HL7 payload saved successfully with interactionId: &quot; + interactionId + &quot; *****&quot;, channelMap);&#xd;
        } else {&#xd;
            logInfo(&quot;***** Failed to save original HL7 payload! *****&quot;, channelMap);&#xd;
        }


        

	
	
	// Extract the XML content from the form-data (i.e., skip the metadata)
	var xmlStartIndex = rawMessage.indexOf(&apos;&lt;?xml&apos;); // Find the XML declaration
	var xmlContent = rawMessage.substring(xmlStartIndex); // Extract the XML part
	
	if (!xmlContent || xmlContent.length === 0) {
		logger.error(&quot;No XML data received in the request.&quot;);
		responseMap.put(&apos;status&apos;, &apos;200&apos;); // Set HTTP status 200.
		responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(&quot;No XML data received in the request.&quot;, &quot;Invalid&quot;)));
		throw new Error(&quot;No XML data received in the request.&quot;);
	}
}



try {
    //var rawTransformedData = connectorMessage.getTransformedData();
     var rawTransformedData = hl7Xml ;
	logger.info(&quot;Raw HL7 Message (pre-clean): &quot; + rawTransformedData);
	

    // Load XSLT from file system
    var xsltPathFromEnv = java.lang.System.getenv(&quot;HL7_XSLT_PATH&quot;) + &quot;/hl7v2-fhir-bundle.xslt&quot;;
    //var xsltPathFromEnv = &quot;hl7v2-fhir-bundle.xslt&quot;;
    logger.info(&quot;HL7_XSLT_PATH: &quot; + xsltPathFromEnv);
    var xsltPath = xsltPathFromEnv;
    var xsltFile = new java.io.File(xsltPath);
    var xsltStream = new java.io.FileInputStream(xsltFile);

    // Create transformer
    var transformerFactory = javax.xml.transform.TransformerFactory.newInstance();
    var xsltSource = new javax.xml.transform.stream.StreamSource(xsltStream);
    var transformer = transformerFactory.newTransformer(xsltSource);
    set_fhir_resource_profile_urls(transformer);

    

    // Optional: pass parameters to XSLT
    var currentTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SS&apos;Z&apos;&quot;).format(new java.util.Date());
    transformer.setParameter(&quot;currentTimestamp&quot;, currentTimestamp);

    var bundleId = java.util.UUID.randomUUID().toString();
    transformer.setParameter(&quot;bundleId&quot;, bundleId);

    var currentTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SS&apos;Z&apos;&quot;).format(new java.util.Date());&#xd;
&#xd;
    transformer = generateSHA256Id(rawTransformedData, &quot;patientRole&quot;, &quot;patientResourceId&quot;, transformer);&#xd;
&#xd;
    transformer = generateSHA256Id(rawTransformedData, &quot;consent&quot;, &quot;consentResourceId&quot;, transformer, currentTimestamp);&#xd;
&#xd;
    transformer = generateSHA256Id(rawTransformedData, &quot;Author&quot;, &quot;organizationResourceId&quot;, transformer);&#xd;
&#xd;
 	transformer = generateSHA256Id(rawTransformedData, &quot;encounter&quot;, &quot;encounterResourceId&quot;, transformer, currentTimestamp);&#xd;
&#xd;
    transformer = generateSHA256Id(rawTransformedData, &quot;sexualOrientation&quot;, &quot;sexualOrientationResourceId&quot;, transformer);&#xd;
&#xd;
    transformer = generateSHA256Id(rawTransformedData, &quot;observations&quot;, &quot;observationResourceSha256Id&quot;, transformer);&#xd;
&#xd;
    transformer = generateSHA256Id(rawTransformedData, &quot;groupObservations&quot;, &quot;observationResourceSha256Id&quot;, transformer);

    

    // Retrieve the X-TechBD-Base-FHIR-URL header
		var customBaseFhirUrl = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Base-FHIR-URL&apos;);
		logger.info(&quot;X-TechBD-Base-FHIR-URL: &quot; + customBaseFhirUrl);


    // Retrieve the VALID_URLS environment variable (comma-separated list)
		var validUrlsEnv = java.lang.System.getenv(&quot;MC_VALID_FHIR_URLS&quot;);
		logger.info(&quot;MC_VALID_FHIR_URLS from environment: &quot; + validUrlsEnv);
		
		// Convert VALID_URLS to an array for validation
		var validUrls = validUrlsEnv ? validUrlsEnv.split(&quot;,&quot;).map(function(url) { return url.trim(); }) : [];
		
		// Check if the header value is valid
		if (customBaseFhirUrl !== null &amp;&amp; customBaseFhirUrl.trim() !== &quot;&quot;) {
		    if (validUrls.includes(customBaseFhirUrl)) {
		        // Store valid value in channelMap
		        transformer.setParameter(&quot;baseFhirUrl&quot;, customBaseFhirUrl);
			   channelMap.put(&apos;baseFhirUrl&apos;, customBaseFhirUrl);
		    } else {
		        // Throw a Bad Request error if the URL is not in the valid list
				var errorMessage = &apos;Bad Request: The provided X-TechBD-Base-FHIR-URL is invalid.&apos;;
				logger.error(errorMessage);
				setErrorResponse(400, errorMessage); // Set the HTTP response status to 400 (Bad Request)
				throw errorMessage; // Stop further processing by throwing an exception
		    }
		}

    
	var sourceXml = connectorMessage.getTransformedData();&#xd;
	getConsentResourceStatus(sourceXml);&#xd;
	getPatientMRN(sourceXml);&#xd;
	getObservationCategoryCodes(transformer, sourceXml);
    // Transform
    var xmlInputStream = new java.io.StringReader(rawTransformedData);
    var xmlOutputStream = new java.io.StringWriter();
    var input = new javax.xml.transform.stream.StreamSource(xmlInputStream);
    var output = new javax.xml.transform.stream.StreamResult(xmlOutputStream);

    try {
    			transformer.transform(input, output);&#xd;		&#xd;			// Store the transformed XML in the channel map&#xd;			var hl7FhirBundle = xmlOutputStream.toString();&#xd;			channelMap.put(&apos;hl7_fhir_bundle&apos;, hl7FhirBundle);&#xd;			logger.info(&quot;HL7 FHIR Bundle: &quot; + hl7FhirBundle);&#xd;&#xd;			var jsonObject = JSON.parse(hl7FhirBundle); // Parse the string into an object&#xd;			var cleanedJsonString = JSON.stringify(jsonObject, removeEmptyValues, 2);&#xd;			logger.info(&quot;Cleaned JSON : &quot; + cleanedJsonString);&#xd;		} catch (e) {
			var errorMsg = &quot;Error processing XML file upload: &quot; + e.message;	
        		// Failure: Return an OperationOutcome JSON response for general errors
        		responseMap.put(&apos;status&apos;, &apos;200&apos;); // Set HTTP status 200.
		    responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;exception&quot;)));
			        &#xd;		    logger.error(&quot;Error during HL7 FHIR bundle transformation: &quot; + e);&#xd;		    throw e;&#xd;		}

		// Convert the XML document to JSON
		const jsonResult = cleanedJsonString;
		channelMap.put(&apos;jsonResult&apos;, jsonResult);
		responseMap.put(&apos;status&apos;, &apos;200&apos;); // Set HTTP status 200.
		responseMap.put(&apos;finalResponse&apos;, JSON.stringify(jsonResult));
 









&#xd;
var processFHIRBundle = globalMap.get(&quot;processFHIRBundle&quot;);&#xd;
if (processFHIRBundle) {&#xd;
    var tenantId = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Tenant-ID&apos;);&#xd;
    channelMap.put(&quot;requestUri&quot;, &quot;/Bundle&quot;);&#xd;
    var validationResults = processFHIRBundle(tenantId, channelMap, jsonResult, responseMap);
    responseMap.put(&apos;status&apos;, &apos;200&apos;); // Set HTTP status 200.&#xd;
    responseMap.put(&quot;finalResponse&quot;, validationResults);&#xd;
} else {&#xd;
    logError(&quot;processFHIRBundle function not found in globalMap.&quot;, channelMap);&#xd;
}





    

    channelMap.put(&apos;xslt_result&apos;, cleanedJsonString);

    
    return cleanedJsonString;

} catch (e) {
    var errorMsg = &quot;Error during XSLT transformation: &quot; + e.message + &quot;\nDetails: &quot; + e;
    logger.error(errorMsg);
    channelMap.put(&apos;xslt_result&apos;, errorMsg);
    throw e;
}

function removeEmptyValues(key, value) {   
// Remove values that are empty strings, null, undefined, or empty objects/arrays   
if (value === &quot;&quot; || value === null || value === undefined ||       
(typeof value === &quot;object&quot; &amp;&amp; Object.keys(value).length === 0) ||       
(Array.isArray(value) &amp;&amp; value.length === 0)) {     
return undefined; // Exclude the key from the result   
}   
return value; // Keep the value as is 
}</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        </elements>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.3">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.3">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.3">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.3">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="4.5.3">
        <elements/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.3">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.3">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.3">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.3">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="4.5.3">
        <elements/>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
  </destinationConnectors>
  <preprocessingScript>message = message.replace(/^\s*(\r?\n)+/, &apos;&apos;);


if ( (sourceMap.get(&apos;contextPath&apos;) == &apos;/hl7v2/Bundle&apos; || sourceMap.get(&apos;contextPath&apos;) == &apos;/hl7v2/Bundle/&apos;) &amp;&amp;
    sourceMap.get(&apos;method&apos;) == &apos;POST&apos;) {&#xd;
&#xd;
// Step 1: Read raw request body&#xd;
var rawData = connectorMessage.getRawData();&#xd;
if (!rawData || rawData.trim().length === 0) {&#xd;
    var errorMessage = &quot;No data provided in the request.&quot;;&#xd;
   // setErrorResponse(400, errorMessage);&#xd;
    throw errorMessage;&#xd;
}&#xd;
&#xd;
// Step 2: Extract boundary and split parts&#xd;
var boundary = rawData.split(&quot;\r\n&quot;)[0];&#xd;
var parts = rawData.split(boundary);&#xd;
&#xd;
var fileContent = null;&#xd;
&#xd;
// Step 3: Try to extract the file part by name=&quot;file&quot;&#xd;
for each (var part in parts) {&#xd;
    if (part.toLowerCase().indexOf(&apos;name=&quot;file&quot;&apos;) !== -1) {&#xd;
        var startIndex = part.indexOf(&quot;\r\n\r\n&quot;);&#xd;
        if (startIndex !== -1) {&#xd;
            fileContent = part.substring(startIndex + 4).trim();&#xd;
            break;&#xd;
        }&#xd;
    }&#xd;
}&#xd;
&#xd;
// Step 4: Fallback - try locating HL7 start (MSH|)&#xd;
if (!fileContent || fileContent.trim().length === 0) {&#xd;
    var mshIndex = rawData.indexOf(&quot;MSH|&quot;);&#xd;
    if (mshIndex !== -1) {&#xd;
        fileContent = rawData.substring(mshIndex).trim();&#xd;
    }&#xd;
}&#xd;
&#xd;
// Step 5: If still no content, throw an error&#xd;
if (!fileContent || fileContent.length === 0) {&#xd;
    var errorMessage = &quot;Could not extract HL7 content from uploaded data.&quot;;&#xd;
   // setErrorResponse(400, errorMessage);&#xd;
    throw errorMessage;&#xd;
}&#xd;
&#xd;
// Step 6: Warn if it doesn&apos;t start with MSH&#xd;
if (!fileContent.startsWith(&quot;MSH|&quot;)) {&#xd;
    logger.warn(&quot;⚠️ Uploaded data does not start with &apos;MSH|&apos;. May not be a valid HL7 message.&quot;);&#xd;
}&#xd;
&#xd;
// Step 7: Convert HL7 to XML&#xd;
var serializationProperties = SerializerFactory.getDefaultSerializationProperties(&apos;HL7V2&apos;);&#xd;
serializationProperties.put(&apos;stripNamespaces&apos;, false);&#xd;
&#xd;
var serializer = SerializerFactory.getSerializer(&apos;HL7V2&apos;, serializationProperties, null);&#xd;
var hl7Xml = serializer.toXML(fileContent);&#xd;
&#xd;
// Step 8: Log for verification&#xd;
logger.info(&quot;✅ HL7 Message Content:\n&quot; + fileContent);&#xd;
logger.info(&quot;✅ HL7 XML Output:\n&quot; + hl7Xml);&#xd;
&#xd;
// Step 9: Store in context maps for downstream use&#xd;
channelMap.put(&quot;hl7RawText&quot;, fileContent);
channelMap.put(&quot;hl7Xml&quot;, hl7Xml);&#xd;
&#xd;
&#xd;







var requestParameters = channelMap.get(&quot;requestParameters&quot;);&#xd;
var SourceType = Packages.org.techbd.config.SourceType;&#xd;
var source = SourceType.HL7.name(); &#xd;
&#xd;
requestParameters.put(Packages.org.techbd.config.Constants.SOURCE_TYPE, source.trim());

 }
 
return message;
</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map

// Version: 0.4.3 - Added support for X-TechBD-Base-FHIR-URL
// Version: 0.4.15 - Added filters to source and bundle destination and changed the globalMap usage to channelMap
/*
var endpoint = channelMap.get(&quot;endpoint&quot;);
if(endpoint == &apos;bundle&apos;) {
	// Get the response from the HTTP Writer destination
	var destinationName = &quot;dest_bundle&quot;;
	var destinationResponse = responseMap.get(destinationName);
	
	// Check if the response exists
	if (destinationResponse) {
	    var responseStatus = destinationResponse.getStatus();  // HTTP status code
	    var responseData = destinationResponse.getMessage();   // Response message body
		responseMap.put(&apos;finalResponse&apos;, responseData);
		
	    // Log the response details
	    logger.info(&quot;Response from &quot; + destinationName + &quot;:&quot;);
	    logger.info(&quot;Status Code: &quot; + responseStatus);
	    logger.info(&quot;Response Data: &quot; + responseData);
	} else {
	    logger.info(&quot;No response found for destination: &quot; + destinationName);
	}
}
*/
return;</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
  <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
  <properties version="4.5.3">
    <clearGlobalChannelMap>true</clearGlobalChannelMap>
    <messageStorageMode>DEVELOPMENT</messageStorageMode>
    <encryptData>false</encryptData>
    <encryptAttachments>false</encryptAttachments>
    <encryptCustomMetaData>false</encryptCustomMetaData>
    <removeContentOnCompletion>false</removeContentOnCompletion>
    <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
    <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
    <initialState>STARTED</initialState>
    <storeAttachments>true</storeAttachments>
    <metaDataColumns>
      <metaDataColumn>
        <name>SOURCE</name>
        <type>STRING</type>
        <mappingName>mirth_source</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>TYPE</name>
        <type>STRING</type>
        <mappingName>mirth_type</mappingName>
      </metaDataColumn>
    </metaDataColumns>
    <attachmentProperties version="4.5.3">
      <type>None</type>
      <properties/>
    </attachmentProperties>
    <resourceIds class="linked-hash-map">
      <entry>
        <string>Default Resource</string>
        <string>[Default Resource]</string>
      </entry>
    </resourceIds>
  </properties>
  <exportData>
    <metadata>
      <enabled>true</enabled>
      <lastModified>
        <time>1754027921182</time>
        <timezone>Asia/Kolkata</timezone>
      </lastModified>
      <pruningSettings>
        <archiveEnabled>true</archiveEnabled>
        <pruneErroredMessages>false</pruneErroredMessages>
      </pruningSettings>
      <userId>1</userId>
    </metadata>
    <channelTags>
      <channelTag>
        <id>9ec6ef81-2762-421a-93b5-8f5b57c7ea6a</id>
        <name>Active</name>
        <channelIds>
          <string>228791e0-c8ac-4d16-ba51-263252f4e6b2</string>
          <string>8ac69fa1-9441-43b7-9ad9-cef544c9384e</string>
          <string>25dd1794-5435-4282-a189-4a2df9aed0a2</string>
          <string>49b0d71c-1ca9-4ac3-ac4e-dc945370f184</string>
          <string>95a4b010-c209-4904-8500-433538921ae5</string>
          <string>3393ac1b-6c87-4c48-a765-240c13a09dc6</string>
          <string>0ab3d3e9-f19d-46d5-9614-46106b435cb3</string>
          <string>9408e60f-8bb1-440e-9d69-1bbba9d59212</string>
        </channelIds>
        <backgroundColor>
          <red>0</red>
          <green>255</green>
          <blue>0</blue>
          <alpha>255</alpha>
        </backgroundColor>
      </channelTag>
    </channelTags>
  </exportData>
</channel>